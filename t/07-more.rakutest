use Test;
use GEOS::Geometry;

plan 38;

# Test point coordinates
my $point = GEOS::Geometry.from-geojson('{"type":"Point","coordinates":[1,4]}');
is $point.x, 1, 'x coordinate';
is $point.y, 4, 'y coordinate';
is $point.z, NaN, 'z coordinate';
is $point.geometry-type, 'Point', 'geometry type';
is $point.dimension, 0, 'point dimension';
ok !$point.is-empty, 'point is not empty';
ok $point.is-valid, 'point is valid';
ok $point.is-simple, 'point is simple';

# Test polygon properties
my $polygon = GEOS::Geometry.from-geojson('{"type":"Polygon","coordinates":[[[0,0],[0,4],[4,4],[4,0],[0,0]]]}');
is $polygon.geometry-type, 'Polygon', 'polygon type';
is $polygon.dimension, 2, 'polygon dimension';
is-approx $polygon.area, 16.0, 'polygon area';
is-approx $polygon.length, 16.0, 'polygon perimeter';

# Test geometric operations
my $buffered = $point.buffer(1);
ok $buffered.area > 3.1, 'buffer creates larger area';
ok $buffered.area < 3.15, 'buffer area is reasonable';

my $centroid = $polygon.centroid;
is-approx $centroid.x, 2.0, 'centroid x';
is-approx $centroid.y, 2.0, 'centroid y';

my $env = $polygon.envelope;
is $env.geometry-type, 'Polygon', 'envelope type';
is-approx $env.area, 16.0, 'envelope area';

# Test serialization
my $wkt = $point.wkt;
like $wkt, /^'POINT'/, 'WKT format';

my $geojson = $point.geojson;
like $geojson, /'Point'/, 'GeoJSON format';

# Test geometric set operations
my $rect1 = GEOS::Geometry.from-geojson('{"type":"Polygon","coordinates":[[[0,0],[0,2],[2,2],[2,0],[0,0]]]}');
my $rect2 = GEOS::Geometry.from-geojson('{"type":"Polygon","coordinates":[[[1,1],[1,3],[3,3],[3,1],[1,1]]]}');

my $intersection = $rect1.intersection($rect2);
is-approx $intersection.area, 1.0, 'intersection area';

my $union = $rect1.union($rect2);
is-approx $union.area, 7.0, 'union area';

my $difference = $rect1.difference($rect2);
is-approx $difference.area, 3.0, 'difference area';

my $sym_diff = $rect1.sym-difference($rect2);
is-approx $sym_diff.area, 6.0, 'symmetric difference area';

# Test spatial predicates
my $point1 = GEOS::Geometry.from-geojson('{"type":"Point","coordinates":[1,1]}');
my $point2 = GEOS::Geometry.from-geojson('{"type":"Point","coordinates":[5,5]}');
my $circle = $point1.buffer(2);

ok $circle.contains($point1), 'circle contains center point';
nok $circle.contains($point2), 'circle does not contain distant point';
ok $point1.within($circle), 'point is within circle';
ok $rect1.intersects($rect2), 'rectangles intersect';
nok $point1.equals($point2), 'different points are not equal';

# Test distance operations
is-approx $point1.distance-to($point2), 5.656854249492381, 'point-to-point distance';
my $point3 = GEOS::Geometry.from-geojson('{"type":"Point","coordinates":[2,2]}');
is-approx $point1.distance-to($point3), 1.4142135623730951, 'diagonal distance';

# Test minimum bounding shape
my $diagonal_line = GEOS::Geometry.from-geojson('{"type":"LineString","coordinates":[[0,0],[1,1],[2,2]]}');
my $buffer = $diagonal_line.buffer(0.1);  # Create a small buffer to ensure area
ok $buffer.area > 0, 'buffered line has area';
ok $buffer.contains($diagonal_line), 'buffer contains original line';

# Test with a polygon instead
my $triangle = GEOS::Geometry.from-geojson('{"type":"Polygon","coordinates":[[[0,0],[1,1],[2,0],[0,0]]]}');
my $triangle_env = $triangle.oriented-envelope;
ok $triangle_env.area > 0, 'triangle envelope has area';
ok $triangle_env.contains($triangle), 'envelope contains original triangle';

# Test boundary operations
my $boundary = $rect1.boundary;
is-approx $boundary.length, 8.0, 'rectangle boundary length';

# Test convex hull
my $points = GEOS::Geometry.from-geojson('{"type":"MultiPoint","coordinates":[[0,0],[1,1],[2,0]]}');
my $hull = $points.convex-hull;
is-approx $hull.area, 1.0, 'triangle hull area';

# Test simplification
my $complex_line = GEOS::Geometry.from-geojson('{"type":"LineString","coordinates":[[0,0],[0.1,0.1],[0.2,0],[0.3,0.1],[1,1]]}');
my $simple_line = $complex_line.simplify(0.2);
ok $simple_line.length < $complex_line.length, 'simplification reduces length';

done-testing;
